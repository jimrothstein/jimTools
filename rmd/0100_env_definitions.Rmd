
	 vim:linebreak:nowrap:nospell:cul tw=78 fo=tqlnr foldcolumn=3 
--- 
# Spaces, no Tabs
title: Template for .Rmd 
date: "`r paste('last updated', 
    format(lubridate::now(), '%H:%M, %d %B %Y'))`"
output: 
  pdf_document: 
    latex_engine: xelatex
toc: TRUE 
toc_depth:  1 
fontsize: 12pt 
geometry: margin=0.5in,top=0.25in 
---

<!-- 
set cul   "cursorline
cc=+1			"colorcolumn is 1 more than tw

vim: to format all urls for md
s/https.*/[&]()/g
-->

Basic Definitions Related to R environemnts:

* Environment

  from Peng 2019, 
  https://bookdown.org/rdpeng/rprogdatascience/scoping-rules-of-r.html


  " An environment is a collection of (symbol, value) pairs, i.e. x is a symbol
  and 3.14 might be its value. Every environment has a parent environment and
  it is possible for an environment to have multiple “children”. The only
  environment without a parent is the empty environment.  "
* Global Environment
```{r global}
ls()
objects()
```

* Hierachcy of Environments
```{r heirarchy}

  search()
```
* Calling Environment (aka parent.frame())

```{r calling}
x  <- 2
y  <- 3
f  <- function() {
  x  <- 20
  y  <- 30
  g(x,y)
}

g  <- function(x,y) {x + y}

# g carries it's calling env with it  and this differs!
g(x,y)  # 5
f()     # 50



```

carries it's env around, here:  explicitly!
```{r }
x  <- 2
y  <- 3

  f  <- function(x,y, env = environment()){
    x  <- env$x
    y  <- env$y
    x + y
  }
f(x,y)

e  <- env()
e$x  <- 200
e$y  <- 300
f(x,y, e)


```

Guess the env
try env_X  as notation
```{r guess}
f  <- function() {
        function() { x }
      }

x  <- 2
g  <- f()   # g is a closure
typeof(g)
g()

# study
formals(g)
body(g)
G  <- environment(g)   # returns an environment
parent.env(G)


# WATCH This!
J  <- new.env()
J$x  <- 20
environment(g)  <- J
g()
ls(envir  = J)
objects(J)


formals(f)
body(f)
environment(f)
```

Should give 200, it does NOT ???
```{r}
f  <- function() {
        function(envir = ENV_X) { x}
      }

ENV_X   <- environment()
x  <- 2
g  <- f()   # g is a closure
typeof(g)
g()

ENV_J   <- new.env()
ENV_J$x   <- 200

ENV_X   <- ENV_J
ENV_X$x

g  <- f()
g()

```

This works, why not above??
```{r}
f  <- function() {
        function() { x}
      }

ENV_J   <- new.env()
ENV_J$x   <- 200


x <- 2

g  <- f()
environment(g)  <- ENV_J
g()

```

STUDY !
```{r simple_env}
x  <- 2
f  <- function(env = NULL ) {x}
f(env = environment())

f()
f(env = ENV_J)  # why 2??
ENV_J$x   #200

parent.env(ENV_J)   # calling env

```

Another version
```{r}
x  <- 2
current_env  <- parent.frame()  # this is current env (despite name)
f  <- function(env = NULL ) { 
  environment()  <- env
  x
}
f (env = environment())

```



* Enclosing Environment

* Executing Environment

* Parent Environment


* Dis efining Environment
  Peng: 
  Typically, you work in  Global Env, where x = is defined and likewise
  function are defined.

```{r defining_env}
# typical just the Global environemtn:basename
x  <-  5
f  <- function() {
  y  <- 2
  x
}
f()

# and check f's defining evn
environment(f)
ls(environment(f))
get("x", environment(f))
get("x", environment(f))
```
  R adds a twist:   Inside a function, you can define another function, so its
  defining environment is NOT Global, but the enviornmnt of the function.

```{r example_defining}
  f  <- function() {
    function() {
      cat("hi from inner \n")
    }
  }

g  <- f()
typeof(g)
g()
```







* Scope
* Closure
  from Peng:

  "The function closure model can be used to create functions that “carry"
  around data with them."


* Permant vs Temporal Environments


```{r setup, include=FALSE		}
knitr::opts_chunk$set(echo = TRUE,
                      comment = "      ##",
                      error = TRUE,
                      collapse = TRUE)
```

<!--  RENDER:  see bottom -->

```{r library, include=FALSE		}
library(jimTools)
``` 


```{r begin}
```

***

```{r knit_exit()} 
knitr::knit_exit()
```

/newpage

```{r render, eval=FALSE	} 
file <- ""
file  <- basename(file)
dir <- "rmd"

jimTools::ren_pdf(file,dir)
jimTools::ren_github(file, dir)
```
